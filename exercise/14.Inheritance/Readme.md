# 継承 

## sample1.cpp

継承とは基本クラスの機能を拡張した派生クラスを作成すること

コンストラクタを指定しない状態で，
派生クラスのインスタンスを作成すると，
基本クラスの引数なしコンストラクタが最初に
呼び出される．

継承の仕方もpublic，protected, privateがある．

## sample2.cpp

呼び出す基本クラスのコンストラクタを指定する

## sample3.cpp

オーバーライド1

オーバーライドとは，基本クラスと全く同じ引数の型，数，
関数名をもったメンバ関数を派生クラスで再定義することである

オーバライドさせた関数を呼び出すときは派生クラスの方が呼び出される

## sample4.cpp

オーバライド2

基本クラスのポインタには派生クラスのインスタンスの
アドレスも代入できる

ただし，オーバライドさせた関数を呼び出すときは基本クラスの方が
呼び出される

## sample5.cpp

仮想関数virtual

ポインタが指すインスタンスの型に応じて，
適切なメンバ関数を呼び出すために
オーバライド元のメンバ関数の先頭にvirtualを付ける

## sample6.cpp

抽象クラス

純粋仮想関数をもつクラス（抽象クラス）の
インスタンスは作成することができないが，
派生クラスでオーバライドすることで，
派生クラスに応じた処理を定義し，利用できる．

## sample7.cpp

typeid演算子（要：`#include<typeinfo>`)

インスタンス（オブジェクト）の型を調べる

## sample8.cpp

多重継承

## sample9.cpp

多重継承

２つ以上の親クラスで同じ名前で定義した
メンバ関数を呼び出したい場合，
スコープ解決演算子を用いる

## sample10.cpp

多重継承の注意点

間接基本クラス1個，直接基本クラス2個のような
多重継承の場合，通常の多重継承の方法では，
派生クラスから間接基本クラスのメンバに
アクセスしようとするとエラーが生じる
（どちらの直接基本クラスを介して呼び出すか曖昧なため）

そこで，直接基本クラスは間接基本クラスを仮想基本クラス
として継承する

## extra1.cpp

派生クラスから基本クラスのメンバにアクセスする

protectedアクセス指定子
